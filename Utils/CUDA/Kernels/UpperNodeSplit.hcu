// Kernels for splitting upper nodes
// -------------------------------------------------------------------
// Copyright (C) 2010 OpenEngine.dk (See AUTHORS) 
// 
// This program is free software; It is covered by the GNU General 
// Public License version 2 or any later version. 
// See the GNU General Public License for more details (see LICENSE). 
//--------------------------------------------------------------------

#include <Meta/CUDA.h>
#include <Utils/CUDA/Utils.h>
#include <Utils/CUDA/SplitVar.h>
#include <Scene/KDPhotonUpperNode.h>
#include <Scene/KDNode.h>
#include <Scene/PhotonNode.h>

#include <Utils/CUDA/Kernels/PhotonMapDeviceVars.h>

using namespace OpenEngine::Scene;

namespace OpenEngine {
namespace Utils {
namespace CUDA {
namespace Kernels {

    __global__ void SetPhotonNodeLeafSide(int *owners,
                                          char *info,
                                          int *leafSide){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        if (id < d_photonNodes){

            int owner = owners[id];
            leafSide[id] = info[owner] != KDNode::LEAF;
        }
        if (id == 0)
            leafSide[d_photonNodes] = 0;
    }

    __global__ void SetPhotonNodeSplitSide(point* photons,
                                           int *owners,
                                           float* splitPos, char *info,
                                           int *splitSide){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        if (id < d_photonNodes){

            point position = photons[id];
            int owner = owners[id];

            float split = splitPos[owner];
            char axis = info[owner];

            // @TODO create something that places the first photons to
            // the left and right photons to the right if equal. (Or
            // forget about it, highly unlikely to happen in a real
            // example!)

            float photonPos = axis == KDNode::X ? position.x : position.y;
            photonPos = axis == KDNode::Z ? position.z : photonPos;
            int side = photonPos < split;
            // Handle leaf before writting to memory
            splitSide[id] = axis == KDNode::LEAF ? 0 : side;
        }
        if (id == 0)
            splitSide[d_photonNodes] = 0;
    }

    __global__ void SplitPhotons(point *photonPos, point *newPos,
                                 int *owners, int *newOwners,
                                 int *splitLeft, int *splitSide,
                                 int *leafLeft, int *leafSide,
                                 int2 *splitAddrs){        
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        int leftTotal = d_photonsMovedLeft;
        int nonLeafTotal = d_nonLeafPhotons;
        /*        
        __shared__ int leftTotal, nonLeafTotal;
        if (threadIdx.x == 0){
            leftTotal = splitLeft[d_photonNodes];
            nonLeafTotal = leafLeft[d_photonNodes];
        }
        
        __syncthreads();
        */
        if (id < d_photonNodes){

            int leafRight = id - leafLeft[id] + nonLeafTotal;
            int left = splitLeft[id];
            int splitRight = leafLeft[id] - left + leftTotal;
            int right = leafSide[id] ? splitRight : leafRight;
            splitAddrs[id] = make_int2(left, right);
            int addr = splitSide[id] ? left : right;
            newPos[addr] = photonPos[id];
            newOwners[addr] = owners[id];
        }
    }

    __global__ void SplitPhotons(point *photonPos, point *newPos,
                                 int *splitLeft, int *splitSide,
                                 int *leafLeft, int *leafSide){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;

        int leftTotal = d_photonsMovedLeft;
        int nonLeafTotal = d_nonLeafPhotons;

        /*        
        __shared__ int leftTotal, nonLeafTotal;
        
        if (threadIdx.x == 0){
            leftTotal = splitLeft[d_photonNodes - 1] + splitSide[d_photonNodes - 1];
            nonLeafTotal = leafLeft[d_photonNodes];
        }

        __syncthreads();
        */

        if (id < d_photonNodes){

            int leafRight = id - leafLeft[id] + nonLeafTotal;
            int left = splitLeft[id];
            int splitRight = leafLeft[id] - left + leftTotal;
            int right = leafSide[id] ? splitRight : leafRight;
            int addr = splitSide[id] ? left : right;
            newPos[addr] = photonPos[id];
        }
    }

    __global__ void SetupLeafNodes(int2 *photonInfo, // [index, range]
                                   int *leafPrefix,
                                   int *leafIDs,
                                   int leafRange){
        
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        int nonLeafTotal = leafPrefix[d_photonNodes];
        
        if (id < leafRange){
            
            int2 info = photonInfo[id];
            info.x = info.x - leafPrefix[info.x] + nonLeafTotal;
            photonInfo[id] = info;
            leafIDs[id] = id + d_activeNodeIndex - leafRange;
        }
    }
    
    __global__ void SetLeafNodeArrays(int *leafIDs,
                                      int leafIndex,
                                      int leafRange){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;        
        if (id < leafRange){
            leafIDs[id] = id + leafIndex;
        }
    }

    /*
    __global__ void SetupLastLeafNodes(int2 *photonInfo, // [index, range]
                                       int *leafPrefix,
                                       int leafRange){
        
        int id = blockDim.x * blockIdx.x + threadIdx.x;
        int stepSize = gridDim.x * blockDim.x;

        __shared__ int nonLeafTotal;
        if (threadIdx.x == 0) nonLeafTotal = leafPrefix[d_photonNodes];

        while (id < leafRange){

            int2 info = photonInfo[id];
            info.x = info.x - leafPrefix[info.x] + nonLeafTotal;
            photonInfo[id] = info;
            
            id += stepSize;
        }
    }
    */


    /**** ========= OLD CODE ============== ****/

/**
 * Setup splitting planes and link to children.
 */
__global__ void SetUpperNodeSplitPlane(KDPhotonUpperNode upperNodes,
                                       unsigned int activeIndex, 
                                       unsigned int activeRange){
    unsigned int id = blockDim.x * blockIdx.x + threadIdx.x;
    unsigned int nodeID = id + activeIndex;
    unsigned int stepSize = gridDim.x * blockDim.x;
    
    while (nodeID < activeIndex + activeRange){
        // the nodes aabb size
        point bbSize = upperNodes.aabbMax[nodeID] - upperNodes.aabbMin[nodeID];
        point median = bbSize * 0.5 + upperNodes.aabbMin[nodeID];
        
        // Calculate splitting plane
        bool yAboveX = bbSize.x < bbSize.y;
        float max = yAboveX ? bbSize.y : bbSize.x;
        float split = yAboveX ? median.y : median.x;
        char axis = yAboveX ? KDPhotonUpperNode::Y : KDPhotonUpperNode::X;
        bool zHigher = max < bbSize.z;
        upperNodes.splitPos[nodeID] = zHigher ? median.z : split;
        upperNodes.info[nodeID] = zHigher ? KDPhotonUpperNode::Z : axis;

        nodeID += stepSize;
    }
}

template<char splitPlane>
__global__ void CalcSplitSide(SplitVar splitVars, 
                  KDPhotonUpperNode upperNodes,
                  PhotonNode photons, unsigned int photonRange,
                  unsigned int nodeID){
    // @TODO replace with symbols
    unsigned int posStart = upperNodes.photonIndex[nodeID];
    float splitPos = upperNodes.splitPos[nodeID];
      
    unsigned int id = blockDim.x * blockIdx.x + threadIdx.x;
    unsigned int stepSize = gridDim.x * blockDim.x;

    while(id < photonRange){
        unsigned int index = id + posStart;
        if (splitPlane == KDPhotonUpperNode::X)
            splitVars.side[id] = photons.pos[index].x < splitPos;
        else if (splitPlane == KDPhotonUpperNode::Y)
            splitVars.side[id] = photons.pos[index].y < splitPos;
        else if (splitPlane == KDPhotonUpperNode::Z)
            splitVars.side[id] = photons.pos[index].z < splitPos;
        id += stepSize;
    }
}

__global__ void SplitPhotons(SplitVar splitVars, 
                            PhotonNode photons,
                            KDPhotonUpperNode upperNodes, unsigned int nodeID){
    // @TODO replace with symbols
    unsigned int photonStart = upperNodes.photonIndex[nodeID];
    unsigned int photonRange = upperNodes.range[nodeID];
    unsigned int totalLeft = splitVars.prefixSum[photonRange - 1] + 
        splitVars.side[photonRange - 1];

    unsigned int id = blockDim.x * blockIdx.x + threadIdx.x;
    unsigned int stepSize = gridDim.x * blockDim.x;

    // Set range values for children
    if (id == 0){
        unsigned int child = upperNodes.child[nodeID];
        upperNodes.photonIndex[child] = photonStart;
        upperNodes.range[child] = totalLeft;
        upperNodes.photonIndex[child+1] = photonStart + totalLeft;
        upperNodes.range[child+1] = photonRange - totalLeft;
    }

    while(id < photonRange){
        unsigned int left = splitVars.prefixSum[id];
        unsigned int right = id - left + totalLeft;
        unsigned int addr = splitVars.side[id] ? left : right;
        splitVars.tempPos[photonStart + addr] = photons.pos[photonStart + id];
        id += stepSize;
    }
}

}
}
}
}
