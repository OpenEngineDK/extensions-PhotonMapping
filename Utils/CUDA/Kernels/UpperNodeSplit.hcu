// Kernels for splitting upper nodes
// -------------------------------------------------------------------
// Copyright (C) 2010 OpenEngine.dk (See AUTHORS) 
// 
// This program is free software; It is covered by the GNU General 
// Public License version 2 or any later version. 
// See the GNU General Public License for more details (see LICENSE). 
//--------------------------------------------------------------------

#include <Meta/CUDA.h>
#include <Utils/CUDA/Utils.h>
#include <Utils/CUDA/SplitVar.h>
#include <Scene/KDPhotonUpperNode.h>
#include <Scene/KDNode.h>
#include <Scene/PhotonNode.h>

#include <Utils/CUDA/Kernels/PhotonMapDeviceVars.h>

using namespace OpenEngine::Scene;

namespace OpenEngine {
namespace Utils {
namespace CUDA {
namespace Kernels {

    __global__ void SetPhotonNodeLeafSide(int *owners,
                                          char *info,
                                          int *leafSide){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        if (id < d_photonNodes){

            int owner = owners[id];
            leafSide[id] = info[owner] != KDNode::LEAF;
            if (info[owner] == KDNode::LEAF) d_createdLeafs = true;
        }
    }

    __global__ void SetPhotonNodeSplitSide(point* photons,
                                           int *owners,
                                           float* splitPos, char *info,
                                           int *splitSide){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        if (id < d_photonNodes){

            point position = photons[id];
            int owner = owners[id];

            float split = splitPos[owner];
            char axis = info[owner];

            // @TODO create something that places the first photons to
            // the left and right photons to the right if equal. (Or
            // forget about it, highly unlikely to happen in a real
            // example!)

            float photonPos = axis == KDNode::X ? position.x : position.y;
            photonPos = axis == KDNode::Z ? position.z : photonPos;
            int side = photonPos < split;
            // Handle leaf before writting to memory
            splitSide[id] = axis == KDNode::LEAF ? 0 : side;
        }
    }

    __global__ void SplitPhotons(point *photonPos, point *newPos,
                                 int *owners, int *newOwners,
                                 int *splitLeft, int *splitSide,
                                 int *leafLeft, int *leafSide,
                                 int2 *splitAddrs){        
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        const int leftTotal = d_photonsMovedLeft;
        const int nonLeafTotal = d_nonLeafPhotons;

        if (id < d_photonNodes){

            int leafRight = id - leafLeft[id] + nonLeafTotal;
            int left = splitLeft[id];
            int splitRight = leafLeft[id] - left + leftTotal;
            int right = leafSide[id] ? splitRight : leafRight;
            splitAddrs[id] = make_int2(left, right);
            int addr = splitSide[id] ? left : right;
            newPos[addr] = photonPos[id];
            newOwners[addr] = owners[id];
        }
    }

    __global__ void SplitPhotons(point *photonPos, point *newPos,
                                 int *owners, int *newOwners,
                                 int *splitLeft, int *splitSide,
                                 int2 *splitAddrs){        
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        const int leftTotal = d_photonsMovedLeft;

        if (id < d_photonNodes){

            int left = splitLeft[id];
            int right = id - left + leftTotal;
            splitAddrs[id] = make_int2(left, right);
            int addr = splitSide[id] ? left : right;
            newPos[addr] = photonPos[id];
            newOwners[addr] = owners[id];
        }
    }

    __global__ void SplitPhotons(point *photonPos, point *newPos,
                                 int *splitLeft, int *splitSide,
                                 int *leafLeft, int *leafSide){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;

        const int leftTotal = d_photonsMovedLeft;
        const int nonLeafTotal = d_nonLeafPhotons;

        if (id < d_photonNodes){

            int leafRight = id - leafLeft[id] + nonLeafTotal;
            int left = splitLeft[id];
            int splitRight = leafLeft[id] - left + leftTotal;
            int right = leafSide[id] ? splitRight : leafRight;
            int addr = splitSide[id] ? left : right;
            newPos[addr] = photonPos[id];
        }
    }

    __global__ void SplitPhotons(point *photonPos, point *newPos,
                                 int *splitLeft, int *splitSide){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        const int leftTotal = d_photonsMovedLeft;

        if (id < d_photonNodes){

            int left = splitLeft[id];
            int right = id - left + leftTotal;
            int addr = splitSide[id] ? left : right;
            newPos[addr] = photonPos[id];
        }
    }

    __global__ void SetupLeafNodes(int2 *photonInfo, // [index, range]
                                   int *leafPrefix,
                                   int *leafIDs,
                                   int leafRange){
        
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        int nonLeafTotal = leafPrefix[d_photonNodes];
        
        if (id < leafRange){
            
            int2 info = photonInfo[id];
            info.x = info.x - leafPrefix[info.x] + nonLeafTotal;
            photonInfo[id] = info;
            leafIDs[id] = id + d_activeNodeIndex - leafRange;
        }
    }
    
    __global__ void SetLeafNodeArrays(int *leafIDs,
                                      int leafIndex,
                                      int leafRange){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;        
        if (id < leafRange){
            leafIDs[id] = id + leafIndex;
        }
    }

}
}
}
}
