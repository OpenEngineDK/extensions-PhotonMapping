// Kernels for sorting upper node children
// -------------------------------------------------------------------
// Copyright (C) 2010 OpenEngine.dk (See AUTHORS) 
// 
// This program is free software; It is covered by the GNU General 
// Public License version 2 or any later version. 
// See the GNU General Public License for more details (see LICENSE). 
//--------------------------------------------------------------------

#include <Meta/CUDA.h>

#include <Scene/KDPhotonUpperNode.h>

using namespace OpenEngine::Scene;

namespace OpenEngine {
namespace Utils {
namespace CUDA {
namespace Kernels {

    /**
     * 0-1 1-2 2-3 3-0 0-2 1-3
     */

    __global__ void UpperNodeMapToGL(point* aabbMin,
                                     point* aabbMax,
                                     float *splitPositions,
                                     char *info,
                                     float3 *vertices,
                                     float3 *colors,
                                     unsigned int size){

        unsigned int id = blockDim.x * blockIdx.x + threadIdx.x;
        unsigned int stepSize = gridDim.x * blockDim.x;

        unsigned int vOffset = 12 * id;

        while (id < size) {

            point min = aabbMin[id];
            point max = aabbMax[id];
            float splitPos = splitPositions[id];

            float3 color;
            point p0, p1, p2, p3;

            switch(info[id]){
            case KDPhotonUpperNode::X:
                color = make_float3(1.0f, 0.0f, 0.0f);
                p0 = make_point(splitPos, min.y, min.z);
                p1 = make_point(splitPos, max.y, min.z);
                p2 = make_point(splitPos, max.y, max.z);
                p3 = make_point(splitPos, min.y, max.z);
                break;
            case KDPhotonUpperNode::Y:
                color = make_float3(0.0f, 1.0f, 0.0f);
                p0 = make_point(min.x, splitPos, min.z);
                p1 = make_point(max.x, splitPos, min.z);
                p2 = make_point(max.x, splitPos, max.z);
                p3 = make_point(min.x, splitPos, max.z);
                break;
            case KDPhotonUpperNode::Z:
                color = make_float3(0.0f, 0.0f, 1.0f);
                p0 = make_point(min.x, min.y, splitPos);
                p1 = make_point(max.x, min.y, splitPos);
                p2 = make_point(max.x, max.y, splitPos);
                p3 = make_point(min.x, max.y, splitPos);
                break;
            case KDPhotonUpperNode::LEAF:
                p0 = p1 = p2 = p3 = make_point(0,0,0);
                break;
            }

            #pragma unroll
            for(unsigned int i= 0; i < 12; ++i)
                colors[vOffset + i] = color;

            vertices[vOffset] = make_float3(p0);
            vertices[vOffset+1] = vertices[vOffset+2] = make_float3(p1);
            vertices[vOffset+3] = vertices[vOffset+4] = make_float3(p2);
            vertices[vOffset+5] = vertices[vOffset+6] = make_float3(p3);
            vertices[vOffset+7] = vertices[vOffset+8] = make_float3(p0);
            vertices[vOffset+9] = make_float3(p2);
            vertices[vOffset+10] = make_float3(p1);
            vertices[vOffset+11] = make_float3(p3);

            id += stepSize;
        }
    }

}
}
}
}
