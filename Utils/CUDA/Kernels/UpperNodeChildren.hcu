// Kernels for sorting upper node children
// -------------------------------------------------------------------
// Copyright (C) 2010 OpenEngine.dk (See AUTHORS) 
// 
// This program is free software; It is covered by the GNU General 
// Public License version 2 or any later version. 
// See the GNU General Public License for more details (see LICENSE). 
//--------------------------------------------------------------------

#include <Meta/CUDA.h>
#include <Utils/CUDA/Utils.h>
#include <Utils/CUDA/Kernels/PhotonMapDeviceVars.h>
#include <Scene/PhotonLowerNode.h>

using namespace OpenEngine::Scene;

namespace OpenEngine {
namespace Utils {
namespace CUDA {
namespace Kernels {

    /**
     * Compute childrens photon index and range and place the values
     * in the children array.
     * 
     * photonInfo has been moved to start at current active node.
     */
    __global__ void SetupChildren(int2 *photonInfo, // [index, range]
                                  int2 *childPhotonInfo, 
                                  int2 *splitAddrs, int *splitLeft,
                                  int *leafSide){
        
        const int id = blockDim.x * blockIdx.x + threadIdx.x;

        bool createdLeaf = false;

        if (id < d_activeNodeRange){

            int2 info = photonInfo[id];
            int photonEnd = info.x + info.y;
            int2 photonIndex = splitAddrs[info.x];
            
            int childIndex = id;
            int leftRange = splitLeft[photonEnd] - photonIndex.x;
            createdLeaf |= leafSide[childIndex] = leftRange <= PhotonLowerNode::MAX_SIZE ? 1 : 0;
            childPhotonInfo[childIndex] = make_int2(photonIndex.x, leftRange);

            childIndex = id + d_activeNodeRange;
            int rightRange = info.y - leftRange;
            createdLeaf |= leafSide[childIndex] = rightRange <= PhotonLowerNode::MAX_SIZE ? 1 : 0;
            childPhotonInfo[childIndex] = make_int2(photonIndex.y, rightRange);
        }
        
        // parallel or
        if (createdLeaf) d_createdLeafs = createdLeaf;
    }

    __global__ void MoveChildInfo(int2 *tempPhotonInfo,
                                  int *splitSide, int *prefixSum,
                                  int *lefts, int* rights,
                                  int2 *photonInfo,
                                  char *nodeInfo){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;

        const int totalLeft = d_leafsCreated;

        if (id < d_activeNodeRange){

            const int parent = id;

            // Copy leftnode
            int leftIndex = id;
            int left = prefixSum[leftIndex];
            int right = leftIndex - left + totalLeft;
            int addr = splitSide[leftIndex] ? left : right;
            lefts[parent] = d_childIndex + addr;
            photonInfo[addr] = tempPhotonInfo[leftIndex];
            nodeInfo[addr] = KDNode::LEAF;
            
            // Copy rightnode
            int rightIndex = id + d_activeNodeRange;
            left = prefixSum[rightIndex];
            right = rightIndex - left + totalLeft;
            addr = splitSide[rightIndex] ? left : right;
            rights[parent] = d_childIndex + addr;
            photonInfo[addr] = tempPhotonInfo[rightIndex];
            nodeInfo[addr] = KDNode::LEAF;
        }
    }

    __global__ void CopyChildInfo(int2 *tempPhotonInfo,
                                  int *left, int* right,
                                  int2 *photonInfo, char *nodeInfo){
        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        if (id < d_activeNodeRange){
            
            // Copy leftnode
            const int leftIndex = id;
            left[id] = d_childIndex + leftIndex;
            photonInfo[leftIndex] = tempPhotonInfo[leftIndex];
            nodeInfo[leftIndex] = KDNode::LEAF;

            // Copy rightnode            
            const int rightIndex = id + d_activeNodeRange;
            right[id] = d_childIndex + rightIndex;
            photonInfo[rightIndex] = tempPhotonInfo[rightIndex];
            nodeInfo[rightIndex] = KDNode::LEAF;
        }
    }

    __global__ void UpdatePhotonOwners(int *owners,
                                       int *left, int *right,
                                       int2 *photonInfo, int activePhotons){

        const int id = blockDim.x * blockIdx.x + threadIdx.x;
        
        if (id < activePhotons){
            
            int owner = owners[id];
            int leftChildIndex = left[owner];
            int rightChildIndex = right[owner];
            int2 leftInfo = photonInfo[leftChildIndex];
            owners[id] = id < leftInfo.x + leftInfo.y ? leftChildIndex : rightChildIndex;
        }
    }


}
}
}
}
