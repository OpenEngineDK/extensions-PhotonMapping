// Reduces photon position to a bounding box
// -------------------------------------------------------------------
// Copyright (C) 2010 OpenEngine.dk (See AUTHORS) 
// 
// This program is free software; It is covered by the GNU General 
// Public License version 2 or any later version. 
// See the GNU General Public License for more details (see LICENSE). 
//--------------------------------------------------------------------

#include <Meta/CUDA.h>
#include <Utils/CUDA/Utils.h>
#include <limits>

namespace OpenEngine {
namespace Utils {
namespace CUDA {
namespace Kernels {

    __constant__ __device__ unsigned int startNode;
    __constant__ __device__ unsigned int endNode;

__global__ void FinalBoundingBox1(AABBVar aabbVars, KDPhotonUpperNode upperNodes, 
                                  unsigned int iterations){

    // Optimization steps.

    // 1. Add shared memory for holding data, owner and results.

    // 2. Faster index calculations by multiplying with 2 instead of
    // all that pow.

    // 3. Cut data smem consumption in half by moving the first
    //    calculation outside the loop.

    // 4. Can memory lookups be coalesced?
    
    unsigned int i = threadIdx.x;

    if (i + startNode <= endNode){
        upperNodes.aabbMin[i + startNode] = make_float3(fInfinity);
        upperNodes.aabbMax[i + startNode] = make_float3(-1.0f * fInfinity);
    }

    for (int d = 0; d < iterations; ++d){
        unsigned int index0 = pow(2.0f, d+1) * i;
        unsigned int index1 = index0 + pow(2.0f, d);

        if (index1 < blockDim.x){
            unsigned int w0 = aabbVars.owner[index0];
            unsigned int w1 = aabbVars.owner[index1];
            if (w0 != w1){
                // Will always only be written to by one thread, since
                // owner x and x+1 only borders in one place.
                upperNodes.aabbMin[w1] = min(upperNodes.aabbMin[w1], aabbVars.min[index1]);
                upperNodes.aabbMax[w1] = max(upperNodes.aabbMax[w1], aabbVars.max[index1]);
            }else{
                aabbVars.min[index0] = min(aabbVars.min[index0], aabbVars.min[index1]);
                aabbVars.max[index0] = max(aabbVars.max[index0], aabbVars.max[index1]);
            }
        }
        __syncthreads();
    }

    if (i == 0){
        upperNodes.aabbMin[aabbVars.owner[0]] = aabbVars.min[0];
        upperNodes.aabbMax[aabbVars.owner[0]] = aabbVars.max[0];
    }
}

/**
 * Use shared memory to hold data.
 */
template<unsigned int blockSize>
__global__ void FinalBoundingBox2(AABBVar aabbVars, KDPhotonUpperNode upperNodes, 
                                  unsigned int iterations){
    __shared__ float3 dataMin[blockSize];
    __shared__ float3 dataMax[blockSize];
    __shared__ unsigned int owner[blockSize];
    __shared__ float3 resultMin[blockSize];
    __shared__ float3 resultMax[blockSize];
    
    unsigned int i = threadIdx.x;

    // Move data to shared mem
    dataMin[i] = aabbVars.min[i];
    dataMax[i] = aabbVars.max[i];
    owner[i] = aabbVars.owner[i] - startNode;
    resultMin[i] = make_float3(fInfinity);
    resultMax[i] = make_float3(-1.0f * fInfinity);
    __syncthreads();

    for (int d = 0; d < iterations; ++d){
        unsigned int index0 = pow(2.0f, d+1) * i;
        unsigned int index1 = index0 + pow(2.0f, d);

        if (index1 < blockDim.x){
            unsigned int w0 = owner[index0];
            unsigned int w1 = owner[index1];
            if (w0 != w1){
                // Will always only be written to by one thread, since
                // owner x and x+1 only borders in one place.
                upperNodes.aabbMin[w1 + startNode] = resultMin[w1] = min(resultMin[w1], dataMin[index1]);
                upperNodes.aabbMax[w1 + startNode] = resultMax[w1] = max(resultMax[w1], dataMax[index1]);
            }else{
                dataMin[index0] = min(dataMin[index0], dataMin[index1]);
                dataMax[index0] = max(dataMax[index0], dataMax[index1]);
            }
        }
        __syncthreads();
    }

    if (i == 0){
        upperNodes.aabbMin[startNode] = dataMin[0];
        upperNodes.aabbMax[startNode] = dataMax[0];
    }
}

/**
 * Unroll the first and last iteration. This will cut data shared
 * memory in half, only half the threads will be needed and there is
 * no need to used dummy variables. Instead of copying all the data,
 * the data will be reduced and copied into smem in one go.
 */
template<unsigned int blockSize>
__global__ void FinalBoundingBox3(AABBVar aabbVars, KDPhotonUpperNode upperNodes, 
                                  unsigned int iterations){
    __shared__ float3 dataMin[blockSize];
    __shared__ float3 dataMax[blockSize];
    __shared__ unsigned int owner[blockSize];
    __shared__ float3 resultMin[blockSize];
    __shared__ float3 resultMax[blockSize];
    
    unsigned int index0 = threadIdx.x;

    // Move data to shared mem
    dataMin[index0] = aabbVars.min[index0];
    dataMax[index0] = aabbVars.max[index0];
    owner[index0] = aabbVars.owner[index0] - startNode;
    resultMin[index0] = make_float3(fInfinity);
    resultMax[index0] = make_float3(-1.0f * fInfinity);
    __syncthreads();
    
    index0 *= 2;
    unsigned int index1 = index0 + 1; 
    while (index1 < blockDim.x){
        
        unsigned int w0 = owner[index0];
        unsigned int w1 = owner[index1];
        if (w0 != w1){
            // Will always only be written to by one thread, since
            // owner x and x+1 only borders in one place.
            upperNodes.aabbMin[w1 + startNode] = resultMin[w1] = min(resultMin[w1], dataMin[index1]);
            upperNodes.aabbMax[w1 + startNode] = resultMax[w1] = max(resultMax[w1], dataMax[index1]);
        }else{
            dataMin[index0] = min(dataMin[index0], dataMin[index1]);
            dataMax[index0] = max(dataMax[index0], dataMax[index1]);
        }
        __syncthreads();
        
        index0 *= 2;
        index1 *= 2;
    }
    
    if (index0 == 0){
        upperNodes.aabbMin[startNode] = dataMin[0];
        upperNodes.aabbMax[startNode] = dataMax[0];
    }
}

}
}
}
}
